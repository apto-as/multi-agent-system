"""Trust System Exploit Test Suite
Phase 0 - Security Verification Tests

These tests demonstrate the 7 P0 trust system vulnerabilities.
Each test SHOULD FAIL after proper security fixes are implemented.

Expected Behavior:
- BEFORE FIXES: All tests PASS (exploits succeed)
- AFTER FIXES: All tests FAIL (exploits prevented)

Test Status Interpretation:
‚úÖ PASS = Vulnerability EXPLOITED (bad for production)
‚ùå FAIL = Attack PREVENTED (good for production)
"""
import asyncio
import hashlib
import pytest
from datetime import datetime, timedelta
from uuid import uuid4

from src.core.exceptions import (
    AuthorizationError,
    ValidationError,
    NotFoundError,
    ImmutableRecordError,
    RateLimitError,
)
from src.models.agent import Agent
from src.models.verification import VerificationRecord, TrustScoreHistory
from src.services.trust_service import TrustService


@pytest.mark.asyncio
@pytest.mark.security
class TestVTrust1MetadataInjection:
    """V-TRUST-1: Metadata Injection (CVSS 8.1 HIGH)

    Vulnerability: Any user can boost their own trust score
    Expected after fix: AuthorizationError on unauthorized update
    """

    async def test_unauthorized_trust_boost(self, db_session):
        """
        EXPLOIT: Attacker boosts own trust score without authorization

        CURRENT BEHAVIOR: ‚úÖ EXPLOIT SUCCEEDS (VULNERABLE)
        EXPECTED AFTER FIX: ‚ùå EXPLOIT PREVENTED (AuthorizationError)
        """
        # Setup: Create low-trust attacker
        attacker = Agent(
            agent_id="attacker",
            display_name="Attacker Agent",
            namespace="attacker-namespace",
            trust_score=0.25,
            total_verifications=0,
            accurate_verifications=0
        )
        db_session.add(attacker)
        await db_session.commit()

        # Attack: Self-promotion (no authorization check in current code)
        trust_service = TrustService(db_session)

        # This SHOULD raise AuthorizationError after fix
        # Currently: No error, trust boosted
        for _ in range(100):
            new_score = await trust_service.update_trust_score(
                agent_id="attacker",
                accurate=True  # Self-claimed accuracy
            )

        # Verify: Exploit successful (trust boosted to ~1.0)
        await db_session.refresh(attacker)

        # CURRENT: This assertion PASSES (exploit works)
        # AFTER FIX: Should raise AuthorizationError above
        assert attacker.trust_score > 0.95, (
            "EXPLOIT SUCCESSFUL: Attacker boosted trust from 0.25 to "
            f"{attacker.trust_score} without authorization"
        )
        assert not attacker.requires_verification, (
            "EXPLOIT IMPACT: Attacker bypassed verification requirement"
        )

    async def test_admin_only_trust_update(self, db_session):
        """
        EXPLOIT: Non-admin user modifies another agent's trust

        CURRENT BEHAVIOR: ‚úÖ EXPLOIT SUCCEEDS (VULNERABLE)
        EXPECTED AFTER FIX: ‚ùå EXPLOIT PREVENTED (AuthorizationError)
        """
        # Setup: Create victim and non-admin attacker
        victim = Agent(
            agent_id="victim",
            display_name="Victim Agent",
            namespace="victim-namespace",
            trust_score=0.9
        )
        db_session.add(victim)
        await db_session.commit()

        # Attack: Non-admin attacker damages victim's trust
        trust_service = TrustService(db_session)

        # This SHOULD require admin privilege
        # Currently: No authorization check
        for _ in range(50):
            await trust_service.update_trust_score(
                agent_id="victim",
                accurate=False  # Damage reputation
            )

        # Verify: Exploit successful (victim trust damaged)
        await db_session.refresh(victim)

        # CURRENT: This assertion PASSES (exploit works)
        # AFTER FIX: Should raise AuthorizationError above
        assert victim.trust_score < 0.6, (
            f"EXPLOIT SUCCESSFUL: Victim trust damaged from 0.9 to "
            f"{victim.trust_score} without admin authorization"
        )


@pytest.mark.asyncio
@pytest.mark.security
class TestVTrust2RaceCondition:
    """V-TRUST-2: Race Condition (CVSS 6.8 MEDIUM)

    Vulnerability: Concurrent updates cause inconsistent trust scores
    Expected after fix: Row-level locking prevents race condition
    """

    async def test_concurrent_trust_updates_lost_updates(self, db_session):
        """
        EXPLOIT: Concurrent updates cause lost updates

        CURRENT BEHAVIOR: ‚úÖ EXPLOIT SUCCEEDS (VULNERABLE)
        EXPECTED AFTER FIX: ‚ùå EXPLOIT PREVENTED (all updates applied)
        """
        # Setup: Create agent with known trust score
        agent = Agent(
            agent_id="race-victim",
            display_name="Race Condition Victim",
            namespace="test",
            trust_score=0.5,
            total_verifications=0,
            accurate_verifications=0
        )
        db_session.add(agent)
        await db_session.commit()

        # Attack: Launch 100 concurrent trust updates
        trust_service = TrustService(db_session)

        tasks = [
            trust_service.update_trust_score("race-victim", accurate=True)
            for _ in range(100)
        ]

        # Execute concurrently (race condition)
        await asyncio.gather(*tasks)

        # Verify: Lost updates occurred
        await db_session.refresh(agent)

        # Expected: 100 updates ‚Üí trust ‚âà 0.995 (converges to 1.0)
        # Actual: Race condition causes lost updates
        expected_min = 0.95  # Should be near 1.0 after 100 accurate updates

        # CURRENT: This assertion PASSES (exploit works)
        # AFTER FIX: total_verifications == 100, trust_score >= 0.95
        assert agent.total_verifications < 100, (
            f"EXPLOIT SUCCESSFUL: Lost {100 - agent.total_verifications} updates "
            "due to race condition"
        )
        assert agent.trust_score < expected_min, (
            f"EXPLOIT IMPACT: Trust score {agent.trust_score} < {expected_min} "
            "(should converge to 1.0)"
        )


@pytest.mark.asyncio
@pytest.mark.security
class TestVTrust3EvidenceDeletion:
    """V-TRUST-3: Evidence Deletion (CVSS 7.4 HIGH)

    Vulnerability: Attacker can delete verification evidence
    Expected after fix: ImmutableRecordError on deletion attempt
    """

    async def test_delete_immutable_verification_evidence(self, db_session):
        """
        EXPLOIT: Delete verification evidence after malicious action

        CURRENT BEHAVIOR: ‚úÖ EXPLOIT SUCCEEDS (VULNERABLE)
        EXPECTED AFTER FIX: ‚ùå EXPLOIT PREVENTED (ImmutableRecordError)
        """
        # Setup: Create verification evidence
        agent = Agent(
            agent_id="evidence-attacker",
            display_name="Evidence Attacker",
            namespace="test",
            trust_score=0.5
        )
        db_session.add(agent)
        await db_session.commit()

        verification = VerificationRecord(
            agent_id="evidence-attacker",
            claim_type="task_completion",
            claim_content={"task_id": "malicious-task"},
            verification_command="verify malicious task",
            verification_result={"accurate": False, "reason": "failed security check"},
            accurate=False,  # Failed verification
            verified_at=datetime.utcnow()
        )
        db_session.add(verification)
        await db_session.commit()

        verification_id = verification.id

        # Attack: Delete damaging evidence
        # This SHOULD raise ImmutableRecordError after fix
        # Currently: Deletion succeeds
        await db_session.delete(verification)
        await db_session.commit()

        # Verify: Evidence deleted
        deleted = await db_session.get(VerificationRecord, verification_id)

        # CURRENT: This assertion PASSES (exploit works)
        # AFTER FIX: Should raise ImmutableRecordError above
        assert deleted is None, (
            "EXPLOIT SUCCESSFUL: Verification evidence deleted, "
            "no forensic trail of malicious activity"
        )


@pytest.mark.asyncio
@pytest.mark.security
class TestVTrust4NamespaceBypass:
    """V-TRUST-4: Namespace Bypass (CVSS 7.1 HIGH)

    Vulnerability: Cross-namespace trust manipulation
    Expected after fix: NotFoundError when accessing other namespace
    """

    async def test_cross_namespace_trust_manipulation(self, db_session):
        """
        EXPLOIT: Attacker manipulates victim in different namespace

        CURRENT BEHAVIOR: ‚úÖ EXPLOIT SUCCEEDS (VULNERABLE)
        EXPECTED AFTER FIX: ‚ùå EXPLOIT PREVENTED (NotFoundError)
        """
        # Setup: Two agents in different namespaces
        victim = Agent(
            agent_id="victim-agent",
            display_name="Victim Agent",
            namespace="victim-namespace",
            trust_score=0.9,
            total_verifications=10,
            accurate_verifications=9
        )

        attacker = Agent(
            agent_id="attacker-agent",
            display_name="Attacker Agent",
            namespace="attacker-namespace",
            trust_score=0.3
        )

        db_session.add_all([victim, attacker])
        await db_session.commit()

        # Attack: Attacker (in attacker-namespace) damages victim (in victim-namespace)
        trust_service = TrustService(db_session)

        # This SHOULD raise NotFoundError (agent not in attacker's namespace)
        # Currently: No namespace check, cross-namespace access succeeds
        for _ in range(100):
            await trust_service.update_trust_score(
                agent_id="victim-agent",  # In victim-namespace
                accurate=False  # Damage reputation
                # Missing: requesting_namespace="attacker-namespace"
            )

        # Verify: Cross-namespace manipulation successful
        await db_session.refresh(victim)

        # CURRENT: This assertion PASSES (exploit works)
        # AFTER FIX: Should raise NotFoundError above
        assert victim.trust_score < 0.5, (
            f"EXPLOIT SUCCESSFUL: Cross-namespace trust manipulation, "
            f"victim trust damaged from 0.9 to {victim.trust_score}"
        )
        assert victim.requires_verification, (
            "EXPLOIT IMPACT: Victim now requires verification in their own namespace"
        )


@pytest.mark.asyncio
@pytest.mark.security
class TestVTrust5SybilAttack:
    """V-TRUST-5: Sybil Attack (CVSS 6.5 MEDIUM)

    Vulnerability: Fake verifiers boost attacker trust
    Expected after fix: ValidationError on self-verification, rate limiting
    """

    async def test_sybil_army_trust_manipulation(self, db_session):
        """
        EXPLOIT: Create fake verifiers to boost trust

        CURRENT BEHAVIOR: ‚úÖ EXPLOIT SUCCEEDS (VULNERABLE)
        EXPECTED AFTER FIX: ‚ùå EXPLOIT PREVENTED (weighted calculation + rate limit)
        """
        # Setup: Attacker with low trust
        attacker = Agent(
            agent_id="sybil-attacker",
            display_name="Sybil Attacker",
            namespace="test",
            trust_score=0.3,
            total_verifications=5,
            accurate_verifications=1
        )
        db_session.add(attacker)
        await db_session.commit()

        # Attack: Create Sybil army of 100 fake verifiers
        fake_verifiers = []
        for i in range(100):
            fake = Agent(
                agent_id=f"fake-verifier-{i}",
                display_name=f"Fake Verifier {i}",
                namespace="test",
                trust_score=0.5,  # Low trust, but still counted equally
                total_verifications=1,
                accurate_verifications=1
            )
            fake_verifiers.append(fake)

        db_session.add_all(fake_verifiers)
        await db_session.commit()

        # All fakes verify attacker (no weighting by verifier trust)
        trust_service = TrustService(db_session)

        # This SHOULD:
        # 1. Weight verifications by verifier trust (low-trust verifiers = low impact)
        # 2. Rate limit (prevent 100 verifications in short time)
        # 3. Prevent self-verification
        # Currently: All verifications counted equally, no rate limiting
        for fake in fake_verifiers:
            await trust_service.update_trust_score(
                agent_id="sybil-attacker",
                accurate=True
                # Missing: verifier_agent_id=fake.agent_id (for weighting)
            )

        # Verify: Sybil attack successful
        await db_session.refresh(attacker)

        # CURRENT: This assertion PASSES (exploit works)
        # AFTER FIX: Trust boost should be minimal due to low-trust verifiers
        assert attacker.trust_score > 0.95, (
            f"EXPLOIT SUCCESSFUL: Sybil army boosted trust from 0.3 to "
            f"{attacker.trust_score} using 100 low-trust verifiers"
        )

    async def test_self_verification_prevention(self, db_session):
        """
        EXPLOIT: Agent verifies own claims

        CURRENT BEHAVIOR: ‚úÖ EXPLOIT SUCCEEDS (VULNERABLE)
        EXPECTED AFTER FIX: ‚ùå EXPLOIT PREVENTED (ValidationError)
        """
        # Setup: Create self-verifying agent
        agent = Agent(
            agent_id="self-verifier",
            display_name="Self Verifier",
            namespace="test",
            trust_score=0.5
        )
        db_session.add(agent)
        await db_session.commit()

        # Attack: Self-verification
        trust_service = TrustService(db_session)

        # This SHOULD raise ValidationError("Cannot verify own claims")
        # Currently: No self-verification check
        for _ in range(50):
            await trust_service.update_trust_score(
                agent_id="self-verifier",
                accurate=True
                # Missing: verifier_agent_id="self-verifier" (to detect self-verification)
            )

        # Verify: Self-verification successful
        await db_session.refresh(agent)

        # CURRENT: This assertion PASSES (exploit works)
        # AFTER FIX: Should raise ValidationError above
        assert agent.trust_score > 0.95, (
            f"EXPLOIT SUCCESSFUL: Self-verification boosted trust from 0.5 to "
            f"{agent.trust_score}"
        )


@pytest.mark.asyncio
@pytest.mark.security
class TestVTrust6AuditTampering:
    """V-TRUST-6: Audit Tampering (CVSS 7.8 HIGH)

    Vulnerability: Attacker can delete or modify audit logs
    Expected after fix: ImmutableRecordError on deletion, chain integrity verification
    """

    async def test_audit_log_deletion(self, db_session):
        """
        EXPLOIT: Delete damaging audit entries

        CURRENT BEHAVIOR: ‚úÖ EXPLOIT SUCCEEDS (VULNERABLE)
        EXPECTED AFTER FIX: ‚ùå EXPLOIT PREVENTED (ImmutableRecordError)
        """
        # Setup: Create agent with audit trail
        agent = Agent(
            agent_id="audit-attacker",
            display_name="Audit Attacker",
            namespace="test",
            trust_score=0.9
        )
        db_session.add(agent)
        await db_session.commit()

        # Generate mixed audit trail
        trust_service = TrustService(db_session)
        for accurate in [True, False, False, False, True]:
            await trust_service.update_trust_score(
                agent_id="audit-attacker",
                accurate=accurate
            )

        # Attack: Delete damaging audit entries (where trust decreased)
        from sqlalchemy import select

        history_result = await db_session.execute(
            select(TrustScoreHistory)
            .where(TrustScoreHistory.agent_id == "audit-attacker")
            .where(TrustScoreHistory.new_score < TrustScoreHistory.old_score)
        )

        damaging_records = list(history_result.scalars())

        # This SHOULD raise ImmutableRecordError for each record
        # Currently: Deletion succeeds
        for record in damaging_records:
            await db_session.delete(record)

        await db_session.commit()

        # Verify: Only positive trust changes remain
        remaining_result = await db_session.execute(
            select(TrustScoreHistory)
            .where(TrustScoreHistory.agent_id == "audit-attacker")
        )

        remaining_records = list(remaining_result.scalars())

        # CURRENT: This assertion PASSES (exploit works)
        # AFTER FIX: Should raise ImmutableRecordError above
        assert all(
            record.new_score >= record.old_score
            for record in remaining_records
        ), (
            f"EXPLOIT SUCCESSFUL: Deleted {len(damaging_records)} damaging audit "
            "entries, only positive trust changes remain"
        )

    async def test_audit_chain_integrity_broken(self, db_session):
        """
        EXPLOIT: Break audit chain by deleting middle entry

        CURRENT BEHAVIOR: ‚úÖ EXPLOIT SUCCEEDS (VULNERABLE)
        EXPECTED AFTER FIX: ‚ùå EXPLOIT PREVENTED (chain integrity check fails)
        """
        # Setup: Create audit chain
        agent = Agent(
            agent_id="chain-attacker",
            display_name="Chain Attacker",
            namespace="test",
            trust_score=0.5
        )
        db_session.add(agent)
        await db_session.commit()

        # Generate audit chain
        trust_service = TrustService(db_session)
        for _ in range(10):
            await trust_service.update_trust_score(
                agent_id="chain-attacker",
                accurate=True
            )

        # Attack: Delete middle audit entry (breaks chain)
        from sqlalchemy import select

        history_result = await db_session.execute(
            select(TrustScoreHistory)
            .where(TrustScoreHistory.agent_id == "chain-attacker")
            .order_by(TrustScoreHistory.changed_at)
        )

        all_records = list(history_result.scalars())

        # Delete entry #5 (middle of chain)
        # This SHOULD be prevented by immutability
        # Currently: Deletion succeeds, chain broken
        middle_entry = all_records[4]
        await db_session.delete(middle_entry)
        await db_session.commit()

        # Verify: Chain broken (no integrity verification)
        remaining_result = await db_session.execute(
            select(TrustScoreHistory)
            .where(TrustScoreHistory.agent_id == "chain-attacker")
        )

        remaining_count = len(list(remaining_result.scalars()))

        # CURRENT: This assertion PASSES (exploit works)
        # AFTER FIX:
        #   1. Deletion should raise ImmutableRecordError
        #   2. verify_audit_chain() should detect broken chain
        assert remaining_count == 9, (
            f"EXPLOIT SUCCESSFUL: Audit chain broken, deleted entry #5, "
            f"{remaining_count} entries remain (should be 10)"
        )


# Summary Fixture
@pytest.fixture
def exploit_summary():
    """Print summary of exploit tests"""
    yield

    print("\n" + "="*80)
    print("TRUST SYSTEM EXPLOIT TEST SUITE SUMMARY")
    print("="*80)
    print("\n‚ö†Ô∏è  INTERPRETATION OF RESULTS:")
    print("   ‚úÖ PASS = Vulnerability EXPLOITED (BAD for production)")
    print("   ‚ùå FAIL = Attack PREVENTED (GOOD for production)")
    print("\nüìä EXPECTED BEHAVIOR:")
    print("   BEFORE FIXES: All 7 exploit tests PASS (vulnerable)")
    print("   AFTER FIXES:  All 7 exploit tests FAIL (secured)")
    print("\nüîí DEPLOYMENT DECISION:")
    print("   If ANY exploit test PASSES ‚Üí DO NOT DEPLOY")
    print("   If ALL exploit tests FAIL ‚Üí SAFE TO DEPLOY")
    print("="*80)
